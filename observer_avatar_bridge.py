#!/usr/bin/env python3
"""
observer_avatar_bridge.py - Bridge between observer system and avatar display
Monitors observer outputs and triggers appropriate avatar messages
"""

import os
import time
import random
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
import threading

try:
    import avatar_display
except ImportError:
    avatar_display = None

class ObserverAvatarBridge:
    def __init__(self):
        self.perception_dir = Path("~/.local/share/goose-perception").expanduser()
        self.last_check_times = {}
        self.last_file_contents = {}
        self.is_running = False
        self.last_suggestions_run = datetime.min
        self.suggestions_interval = timedelta(minutes=15)  # Run avatar suggestions every 15 minutes
        self.last_idle_chatter = datetime.min
        self.idle_chatter_interval = timedelta(minutes=5)  # Show idle chatter every 5 minutes
        self.last_suggestion_show = datetime.min
        self.suggestion_show_interval = timedelta(minutes=8)  # Show existing suggestions every 8 minutes
        
        # Ensure perception directory exists
        self.perception_dir.mkdir(parents=True, exist_ok=True)
        
        # Files to monitor
        self.monitored_files = {
            'WORK.md': 'work',
            'LATEST_WORK.md': 'work',
            'INTERACTIONS.md': 'interaction',
            'CONTRIBUTIONS.md': 'productivity',
            'ACTIVITY-LOG.md': 'general',
            'AVATAR_SUGGESTIONS.md': 'suggestions',
            'ACTIONABLE_SUGGESTIONS.md': 'actionable'
        }
        
        # Chit-chat will now be generated by recipe instead of hardcoded
        self.chatter_interval = timedelta(minutes=8)  # Generate new chatter every 8 minutes
        self.last_chatter_run = datetime.now() - self.chatter_interval
    
    def start_monitoring(self):
        """Start monitoring observer files"""
        if avatar_display is None:
            print("Avatar display not available, bridge disabled")
            return
            
        self.is_running = True
        monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        monitor_thread.start()
        print("üîó Observer-Avatar bridge started...")
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.is_running = False
    
    def _monitor_loop(self):
        """Main monitoring loop"""
        while self.is_running:
            try:
                self._check_files()
                # Check every 15 seconds for more responsive avatar
                time.sleep(15)
            except Exception as e:
                print(f"Error in observer bridge: {e}")
                time.sleep(60)  # Wait longer on error
    
    def _check_files(self):
        """Check monitored files for changes"""
        current_time = datetime.now()
        
        # Check if it's time to run avatar suggestions (generate new ones)
        if current_time - self.last_suggestions_run > self.suggestions_interval:
            self._run_avatar_suggestions()
            self._run_actionable_suggestions()  # Also check for actionable suggestions
            self.last_suggestions_run = current_time
        
        # Check if it's time to show existing suggestions
        elif current_time - self.last_suggestion_show > self.suggestion_show_interval:
            self._show_existing_suggestion()
            self.last_suggestion_show = current_time
            
        # Check if it's time for idle chatter
        elif current_time - self.last_idle_chatter > self.idle_chatter_interval:
            self._show_idle_chatter()
            self.last_idle_chatter = current_time
            
        # Check if it's time to generate new chit-chat
        elif current_time - self.last_chatter_run > self.chatter_interval:
            self._run_chatter_recipe()
            self.last_chatter_run = current_time
        
        for filename, category in self.monitored_files.items():
            file_path = self.perception_dir / filename
            
            if not file_path.exists():
                continue
                
            try:
                # Get file modification time
                mod_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                last_check = self.last_check_times.get(filename, datetime.min)
                
                # If file was modified since last check
                if mod_time > last_check:
                    self.last_check_times[filename] = current_time
                    
                    # Read new content
                    new_content = file_path.read_text()
                    old_content = self.last_file_contents.get(filename, "")
                    
                    # Check if content actually changed
                    if new_content != old_content:
                        self.last_file_contents[filename] = new_content
                        self._process_file_change(filename, new_content, old_content, category)
                        
            except Exception as e:
                print(f"Error checking {filename}: {e}")
    
    def _run_avatar_suggestions(self):
        """Run the avatar suggestions observer recipe"""
        try:
            print("üîç Running avatar suggestions observer recipe...")
            
            # Run the goose recipe
            result = subprocess.run([
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-suggestions.yaml"
            ], capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print("‚úÖ Avatar suggestions recipe completed successfully")
                self._process_new_suggestions()
            else:
                print(f"‚ùå Avatar suggestions recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Avatar suggestions recipe timed out")
        except Exception as e:
            print(f"Error running avatar suggestions: {e}")
    
    def _run_actionable_suggestions(self):
        """Run the actionable suggestions observer recipe"""
        try:
            print("üéØ Running actionable suggestions observer recipe...")
            
            # Run the goose recipe
            result = subprocess.run([
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-actionable-suggestions.yaml"
            ], capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                print("‚úÖ Actionable suggestions recipe completed successfully")
                self._process_actionable_suggestions()
            else:
                print(f"‚ùå Actionable suggestions recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Actionable suggestions recipe timed out")
        except Exception as e:
            print(f"Error running actionable suggestions: {e}")
    
    def _run_chatter_recipe(self):
        """Run the chit-chat recipe to generate contextual casual messages"""
        try:
            print("üí¨ Running avatar chit-chat recipe...")
            
            # Run the goose recipe
            result = subprocess.run([
                "goose", "run", "--no-session", 
                "--recipe", "observers/recipe-avatar-chatter.yaml"
            ], capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                print("‚úÖ Avatar chit-chat recipe completed successfully")
            else:
                print(f"‚ùå Avatar chit-chat recipe failed: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            print("‚è∞ Avatar chit-chat recipe timed out")
        except Exception as e:
            print(f"Error running avatar chit-chat: {e}")
    
    def _parse_suggestions_file(self):
        """Parse the AVATAR_SUGGESTIONS.md file and return suggestions"""
        suggestions_file = self.perception_dir / "AVATAR_SUGGESTIONS.md"
        suggestions = []
        
        if not suggestions_file.exists():
            return suggestions
            
        try:
            content = suggestions_file.read_text()
            lines = content.strip().split('\n')
            
            for line in lines:
                if ':' in line and not line.startswith('#'):
                    suggestion_type, message = line.split(':', 1)
                    suggestions.append({
                        'type': suggestion_type.strip(),
                        'message': message.strip().strip('"')
                    })
            
            return suggestions
        except Exception as e:
            print(f"Error parsing suggestions file: {e}")
            return []
    
    def _parse_chatter_file(self):
        """Parse the AVATAR_CHATTER.md file and return casual messages"""
        chatter_file = self.perception_dir / "AVATAR_CHATTER.md"
        messages = []
        
        if not chatter_file.exists():
            return messages
            
        try:
            content = chatter_file.read_text()
            lines = content.strip().split('\n')
            
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    messages.append(line)
            
            return messages
        except Exception as e:
            print(f"Error parsing chatter file: {e}")
            return []
    
    def _parse_actionable_suggestions_file(self):
        """Parse the ACTIONABLE_SUGGESTIONS.md file and return actionable suggestions"""
        actionable_file = self.perception_dir / "ACTIONABLE_SUGGESTIONS.md"
        suggestions = []
        
        if not actionable_file.exists():
            return suggestions
            
        try:
            content = actionable_file.read_text()
            lines = content.strip().split('\n')
            
            for line in lines:
                if line.count(':') >= 3 and not line.startswith('#'):
                    parts = line.split(':', 3)
                    if len(parts) == 4:
                        action_type, observation_type, suggestion_text, action_command = parts
                        suggestions.append({
                            'action_type': action_type.strip(),
                            'observation_type': observation_type.strip(),
                            'message': suggestion_text.strip(),
                            'action_command': action_command.strip()
                        })
            
            return suggestions
        except Exception as e:
            print(f"Error parsing actionable suggestions file: {e}")
            return []
    
    def _process_actionable_suggestions(self):
        """Process newly generated actionable suggestions"""
        actionable_suggestions = self._parse_actionable_suggestions_file()
        
        if actionable_suggestions:
            # Pick the most relevant/urgent actionable suggestion
            suggestion = random.choice(actionable_suggestions)
            
            # Show immediately - actionable suggestions are high priority!
            self._show_actionable_suggestion(suggestion)
            print(f"üéØ Immediately showing actionable suggestion: {suggestion['message']}")
    
    def _show_actionable_suggestion(self, suggestion):
        """Show an actionable suggestion with action buttons"""
        if avatar_display and hasattr(avatar_display, 'avatar_instance') and avatar_display.avatar_instance:
            try:
                # Create action data for the suggestion
                action_data = {
                    'action_type': suggestion['action_type'],
                    'action_command': suggestion['action_command'],
                    'observation_type': suggestion['observation_type']
                }
                
                # Show the suggestion with action buttons (uses default 75-second duration)
                avatar_display.avatar_instance.show_message(
                    suggestion['message'], 
                    avatar_state='pointing',
                    action_data=action_data
                )
                
            except Exception as e:
                print(f"Error showing actionable suggestion: {e}")
    
    def _process_new_suggestions(self):
        """Process newly generated suggestions and show immediately"""
        suggestions = self._parse_suggestions_file()
        
        if not suggestions:
            return
            
        # Show new suggestions immediately - they're fresh and relevant!
        suggestion = random.choice(suggestions)
        self._show_suggestion(suggestion)
        print(f"üí° Immediately showing new suggestion: {suggestion['message']}")
    
    def _show_existing_suggestion(self):
        """Show a suggestion from the existing pool"""
        suggestions = self._parse_suggestions_file()
        
        if not suggestions:
            return
            
        # Show existing suggestions with moderate probability
        if random.random() < 0.4:  # 40% chance to show existing suggestion
            suggestion = random.choice(suggestions)
            self._show_suggestion(suggestion)
    
    def _show_suggestion(self, suggestion):
        """Helper method to show a suggestion with proper avatar state"""
        # Map suggestion types to avatar states
        suggestion_types = {
            'productivity': 'work',
            'collaboration': 'meetings', 
            'focus': 'focus',
            'attention': 'attention',
            'optimization': 'optimization',
            'break': 'break',
            'system': 'optimization'
        }
        
        suggestion_type = suggestion_types.get(suggestion['type'], 'work')
        message = suggestion['message']
        
        if avatar_display:
            avatar_display.show_suggestion(suggestion_type, message)
    
    def _show_idle_chatter(self):
        """Show casual idle chatter from recipe-generated content"""
        if not avatar_display:
            return
            
        # Show idle chatter with higher probability since it's contextual now
        if random.random() < 0.5:  # 50% chance for idle chatter
            chatter_messages = self._parse_chatter_file()
            if chatter_messages:
                message = random.choice(chatter_messages)
                avatar_display.show_message(message, 4000)
    
    def _process_file_change(self, filename, new_content, old_content, category):
        """Process a file change and potentially trigger avatar message"""
        try:
            # Handle avatar suggestions file updates
            if filename == 'AVATAR_SUGGESTIONS.md':
                self._process_new_suggestions()
                return
            
            # For other files, occasionally show a contextual message
            if random.random() > 0.3:  # 30% chance to show message
                return
                
            # Simple fallback messages for file changes
            if filename == 'LATEST_WORK.md':
                if avatar_display:
                    avatar_display.show_message("üìù I see you're updating your current work focus...")
            elif filename == 'INTERACTIONS.md':
                if avatar_display:
                    avatar_display.show_message("ü§ù New interaction data updated...")
            elif filename == 'CONTRIBUTIONS.md':
                if avatar_display:
                    avatar_display.show_message("üìà Your contribution patterns have been updated...")
                
        except Exception as e:
            print(f"Error processing {filename} change: {e}")
    

    
    def trigger_contextual_message(self):
        """Trigger a contextual message from recipes"""
        if avatar_display is None:
            return
        
        # Try to show a chit-chat message from recipe-generated content
        chatter_messages = self._parse_chatter_file()
        if chatter_messages:
            message = random.choice(chatter_messages)
            avatar_display.show_message(message, 4000)
        else:
            # Fallback to simple interaction if no chatter available
            avatar_display.show_message("üëã How's it going?", 3000)

# Global bridge instance
bridge_instance = None

def start_observer_bridge():
    """Start the observer-avatar bridge"""
    global bridge_instance
    
    if bridge_instance is None:
        bridge_instance = ObserverAvatarBridge()
        bridge_instance.start_monitoring()
    
    return bridge_instance

def trigger_contextual_message():
    """Trigger a contextual message (can be called from other modules)"""
    global bridge_instance
    if bridge_instance:
        bridge_instance.trigger_contextual_message()

if __name__ == "__main__":
    # Test the bridge
    import avatar_display
    
    # Start avatar system
    avatar_display.start_avatar_system()
    time.sleep(2)
    
    # Start bridge
    bridge = start_observer_bridge()
    
    print("üîó Observer-Avatar bridge test running...")
    print("This will monitor observer files and trigger avatar messages.")
    print("Press Ctrl+C to stop.")
    
    try:
        while True:
            # Occasionally trigger contextual messages for testing
            if random.random() < 0.1:  # 10% chance every loop
                bridge.trigger_contextual_message()
            time.sleep(10)
    except KeyboardInterrupt:
        print("\nüëã Bridge test ended.")
        bridge.stop_monitoring() 